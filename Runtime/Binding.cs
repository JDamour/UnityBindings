using UnityEngine;
using System;
using System.Reflection;
using System.ComponentModel;

namespace Gameframe.Bindings
{
    /// <summary>
    /// Maintains a one directional binding between two properties
    /// Property change events generated by the source will assign and update the target property
    /// </summary>
    public class Binding : IDisposable
    {
        private object _source;
        private object _target;

        private string _sourcePath;

        private PropertyInfo _sourceProperty;
        private PropertyInfo _targetProperty;
        
        private INotifyPropertyChanged _propertyChangedNotifier;

        private bool disposed;

        /// <summary>
        /// Error context is passed to any error logs so that errors selected in the console
        /// Will direct the user to the associated context object
        /// </summary>
        private UnityEngine.Object errorContext;
        public UnityEngine.Object ErrorContext
        {
            get => errorContext;
            set => errorContext = value;
        }

        /// <summary>
        /// Changes will only propagate while enabled is true
        /// </summary>
        private bool enabled = true;
        public bool Enabled
        {
            get => enabled;
            set => enabled = value;
        }
        
        /// <summary>
        /// Converter function will transform values before assigning the target property
        /// </summary>
        private Func<object, object> converter;
        public Func<object, object> Converter
        {
            get => converter;
            set => converter = value;
        }

        /// <summary>
        /// Set the binding source. This hooks up where your data comes from.
        /// If the dataContext implements INotifyPropertyChanged it will also set up to listen for change events
        /// </summary>
        /// <param name="dataContext">The object to be used as the data context</param>
        /// <param name="path">path to the property you wish to bind to</param>
        /// <param name="refresh">if true the property will be immediately refreshed after binding is updated</param>
        public void SetSource(object dataContext, string path, bool refresh = true)
        {
            _source = dataContext;
            _sourcePath = path;
            _sourceProperty = GetPropertyInfo(dataContext, path);
            SetPropertyChangedNotifier(_source as INotifyPropertyChanged);
            if (refresh)
            {
                Refresh();
            }
        }
        
        /// <summary>
        /// Set the binding target. This is the property that gets set when the binding is refreshed
        /// If the source implements INotifyPropertyChanged the target should get refreshed automatically
        /// </summary>
        /// <param name="dataContext">target that contains the property at path</param>
        /// <param name="path">path to the property that will be set</param>
        /// <param name="refresh">If true the binding will refresh immediately after being set</param>
        public void SetTarget(object dataContext, string path, bool refresh = true)
        {
            _target = dataContext;
            _targetProperty = GetPropertyInfo(dataContext, path);
            if (refresh)
            {
                Refresh();
            }
        }

        /// <summary>
        /// Refresh the target value with the value from the source
        /// </summary>
        public void Refresh()
        {
            if (_target == null || _source == null || _targetProperty == null || _sourceProperty == null || disposed)
            {
                return;
            }

            try
            {
                var sourceValue = _sourceProperty.GetValue(_source, null);
                if (Converter != null)
                {
                    sourceValue = Converter(sourceValue);
                }
                _targetProperty.SetValue(_target, sourceValue);
            }
            catch (Exception e)
            {
                Debug.LogException(e, ErrorContext);
            }
        }

        private void PropertyChanged(object sender, PropertyChangedEventArgs args)
        {
            if (disposed)
            {
                throw new ObjectDisposedException("Binding was disposed but still getting property changed events.");
            }
            
            if ( _targetProperty == null || !Enabled )
            {
                return;
            }
            
            if (_sourcePath.Contains(args.PropertyName))
            {
                Refresh();
            }
        }
        
        private static PropertyInfo GetPropertyInfo(object obj, string path)
        {
            if (obj == null || path == null)
            {
                return null;
            }
            var type = obj.GetType();
            return type.GetProperty(path);
        }
        
        private void SetPropertyChangedNotifier(INotifyPropertyChanged value)
        {
            if (_propertyChangedNotifier != null)
            {
                _propertyChangedNotifier.PropertyChanged -= PropertyChanged;
            }
            _propertyChangedNotifier = value;
            if (_propertyChangedNotifier != null)
            {
                _propertyChangedNotifier.PropertyChanged += PropertyChanged;
            }
        }
        
        /// <summary>
        /// Destroys the binding so changes will no longer propagate 
        /// </summary>
        public void Dispose()
        {
            disposed = true;
            SetPropertyChangedNotifier(null); 
        }
        
        ~Binding()
        {
            if (!disposed)
            {
                Dispose();
            }
        }
        
    }
}